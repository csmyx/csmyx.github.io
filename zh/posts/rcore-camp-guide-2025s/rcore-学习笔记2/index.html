<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>rCore 学习笔记2 | csmyx</title>
<meta name="keywords" content="">
<meta name="description" content="系列: rCore-Camp-Guide-2025S，对应文档第4章的内容">
<meta name="author" content="csmyx">
<link rel="canonical" href="https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.745fdfc466afc3572ead96423ed5fa4b204215d49f84183b10faa939bc5db88d.css" integrity="sha256-dF/fxGavw1curZZCPtX6SyBCFdSfhBg7EPqpObxduI0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://csmyx.github.io/favicon/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://csmyx.github.io/favicon/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://csmyx.github.io/favicon/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://csmyx.github.io/favicon/apple-touch-icon.png">
<link rel="mask-icon" href="https://csmyx.github.io/favicon/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/">
  <meta property="og:site_name" content="csmyx">
  <meta property="og:title" content="rCore 学习笔记2">
  <meta property="og:description" content="系列: rCore-Camp-Guide-2025S，对应文档第4章的内容">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-13T19:38:02+08:00">
    <meta property="article:modified_time" content="2025-04-13T19:38:02+08:00">
      <meta property="og:image" content="https://csmyx.github.io/img/1.png">
      <meta property="og:see_also" content="https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">
      <meta property="og:see_also" content="https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://csmyx.github.io/img/1.png">
<meta name="twitter:title" content="rCore 学习笔记2">
<meta name="twitter:description" content="系列: rCore-Camp-Guide-2025S，对应文档第4章的内容">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "文章",
      "item": "https://csmyx.github.io/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "rCore 学习笔记2",
      "item": "https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "rCore 学习笔记2",
  "name": "rCore 学习笔记2",
  "description": "系列: rCore-Camp-Guide-2025S，对应文档第4章的内容",
  "keywords": [
    
  ],
  "articleBody": "总结到chapter4的内容，练习和问答作业，重点是地址空间隔离机制的实现。\n地址空间隔离 实现机制 [todo]\n地址映射关系 一图流，秒了（画图画累了，写不动了，后面再补充文字描述吧[todo]）\ntrap陷入过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 __alltraps: csrrw sp, sscratch, sp # now sp-\u003e*TrapContext in user space, sscratch-\u003euser stack # save other general purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they have been saved in TrapContext csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it in TrapContext csrr t2, sscratch sd t2, 2*8(sp) # load kernel_satp into t0 ld t0, 34*8(sp) # load trap_handler into t1 ld t1, 36*8(sp) # move to kernel_sp ld sp, 35*8(sp) # switch to kernel space csrw satp, t0 sfence.vma # jump to trap_handler jr t1 流程如下：\n1-22行：保存trap context（即当前所有寄存器的值）到用户栈上\n当trap发生时，此时还处于用户空间，然后sp和sscratch分别指向用户栈顶和用户栈上的trap context。执行csrrw之后，sp指向了分配的trap context，然后就可以开始执行保存trap context的操作：就是执行一系列的sd操作，将寄存器的值保存到sp指向的trap context中。需要注意真正需要保存的x2（即sp）的值在sscratch中，需要特殊处理一下。\n23-31 行：从用户空间切换到内核空间，跳转到trap handler执行\n执行到 23 行时我们仍处于用户空间，具体来说，我们需要设置 3 个寄存器的值，这 3 个寄存器的值都从trap context中获取。\n设置sp寄存器，指向内核栈 设置ra寄存器，指向trap handler 设置stap寄存器，指向内核空间（页表）的根地址，此时就切换到内核空间了 需要注意，由于这些寄存器的值是从用户栈上的获取，必须必须在第 30 行设置stap之前完成读取。\n32-33行：跳到trap_handler，这里使用jump register 而不是像第二章时直接call trap_handler，是因为后者是根据相对虚拟地址来跳转，而前者是根据绝对虚拟地址。开启MMU后，由于我们的trampline和实际物理地址不是直接映射，所以相对虚拟地址就不对了\n完成设置之后，就可以跳转到trap handler，在内核地址空间里\t处理trap了\n以上流程的正确执行需要如下Preconditions：\n已经在用户栈上分配了trap context的空间，且其中保存了3个重要的值：内核栈地址、trap handler地址、内核空间根页表物理地址 sp指向用户栈顶，sscratch指向用户栈上的trap context 然后执行之后存在如下Postconditions：\n处于内核地址空间 sp指向内核栈顶 用户进程的trap context已经保存到了用户栈上，且sscratch指向用户栈顶 trap返回过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 __restore: # a0: *TrapContext in user space(Constant); a1: user space token # switch to user space csrw satp, a1 sfence.vma csrw sscratch, a0 mv sp, a0 # now sp points to TrapContext in user space, start restoring based on it # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) csrw sstatus, t0 csrw sepc, t1 # restore general purpose registers except x0/sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # back to user stack ld sp, 2*8(sp) sret Preconditions: a0 指向用户栈上的trap context，a1指向用户空间根页表物理地址 流程如下： 1-5行：切换回用户空间 6行：将a0保存到sscratch 7行-23行：根据a0恢复trap context 24行：sret回到用户态（U mode） Postconditions： sscratch指向用户栈上的trap context 处于用户地址空间 已经根据trap context重置了寄存器状态 相关问题 以下问题是我个人学习过程中的遇到的几个困惑点，以及思考后得出来的答案，类似于官方的问答作业吧。如果这些问题你都能答得上来的话，说明本章的内容你掌握的很好了。（当然答案都是我的个人理解，如果有误，欢迎指正）\n假设存在N个app，此时有几个页表？有几个虚拟页同时映射到trampoline这个物理页？\n答：朴素的答案是N+1，N+2。考虑系统调用时，会通过PageTable::from_token，构造一个临时页表用于访问用户空间，但是该临时页表其实也是复用的用户页表的根页表，所以不会影响答案。\n为什么call trap_handler需要换成jr t1？为啥call只能是对pc的相对虚拟地址调整，而不能是直接对pc赋值为绝对虚拟地址？\n答：原因和地址长度及指令长度相关。\n如果我使用call trap_handler，是否有可能能够正常执行？如果去掉.text.trampoline之后的align(4K)之后，有没有可能呢？如果在内核态出错（比如call trap_handler导致出错）会发生什么情况\n为啥需要在用户空间专门分配一个页面来保存trap context，而不是继续保存在内核栈上？\n答：因为只有一个备用寄存器sscratch，无法同时保存satp和kernel_stack_top的值。于是我们统一将satp和kernel_stack_top的值保存用户页面上中，然后scratch保存该页面的地址即可通过sscratch同时获取这两个值了。\n为啥需要 set_kernel_trap_entry和 set_user_trap_entry？\n在用户态执行时（陷入内核之前），sscratch的值是啥？\n答：始终等于TRAP_CONTEXT_BASE。\ntrap_context中有哪些变量是用于读的，哪些是用于写的？用于读的的变量的值在初始化之后会被修改吗？\n答：kernel_stap, kernel_sp, trap_handler是用于读的，其余是用于写的。其中kernel_satp和kernel_sp在初始化之后保持不变，而trap_handler在进入trap_handler时会被设置成trap_from_kernel，而在进入trap_return时会被设置回TRAMPOLINE。\nchapter4练习 实现内容 重写 sys_get_time 和 sys_trace 实现mmap 和 munmap 实现概要 以下是一些重要注意事项（待完善，[todo]）\nPageTable::from_token只是用于trap后处于内核空间时，通过该token临时构造一个用于查询用户内存空间的页表，该页表不会被赋值给satp，不进行实际的地址转换作用，不负责管理用户帧的分配回收，frames置为空。\n而在sys_mmap中涉及到分配frame之后，就不再能够使用PageTable::from_token临时构造页表了，而是直接使用用户空间的原始内核页表，而且光使用页表也是不够的，需要直接调用 memory_set的insert_framed_area 方法添加一个map_area。\n尝试构造非法虚拟地址，看调用sys_get_time或sys_trace是否符合预期，返回 -1\n为啥测试用例调用 4 次get_time，但只是assert(3 \u003c= count(sys_get_time))?\n页表标志位用法：最低一级页表的pte，除了V标志位以外，RWXU标志位也有效（因为pte中存的是物理帧地址），而其它级别页表由于pte中存的是下一级的页表的物理地址，所以只有V标志位有用。而且有一个细节，最低一级页表的pte的标志位是在PageTable::map中完成的，而其它级别页表的pte的标志位是在PageTable::find_pte_create中设置的。\n最低一级页表的RWXU标志位是根据逻辑段MapArea的map permission来设置，因此用户可访问权限的逻辑段的初始化，一定要赋予该U权限。\n与该标志位设置相关的bugfix：\n问答作业 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？\n答：页表项总共64位，可以这样记：高10位为保留字段，低10位为标志位，中间44位为物理页号.\n其中各个标志位的作用为：\nV: 页表项是否合法 R/W/X：对该页表项所指向的物理页面是否有读/写/执行权限。（参看实现概要中我的思考，这些字段仅针对第三级页表项） U：是否允许 CPU 在处于 U 特权级时访问该页表项所指向的物理页面 A：自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过 D：自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过 缺页\n缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。\n请问哪些异常可能是缺页导致的？\n答：[todo]\n发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。\n缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\n这样做有哪些好处？ 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？ 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\n此时页面失效如何表现在页表项(PTE)上？ 双页表与单页表\n为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n在单页表情况下，如何更换页表？ 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问） 单页表有何优势？（回答合理即可） 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ ",
  "wordCount" : "3965",
  "inLanguage": "zh",
  "image": "https://csmyx.github.io/img/1.png","datePublished": "2025-04-13T19:38:02+08:00",
  "dateModified": "2025-04-13T19:38:02+08:00",
  "author":{
    "@type": "Person",
    "name": "csmyx"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "csmyx",
    "logo": {
      "@type": "ImageObject",
      "url": "https://csmyx.github.io/favicon/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://csmyx.github.io/zh/" accesskey="h" title="csmyx (Alt + H)">csmyx</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://csmyx.github.io/zh/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://csmyx.github.io/zh/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://csmyx.github.io/zh/series/" title="系列">
                    <span>系列</span>
                </a>
            </li>
            <li>
                <a href="https://csmyx.github.io/zh/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://csmyx.github.io/zh/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://csmyx.github.io/zh/">首页</a>&nbsp;»&nbsp;<a href="https://csmyx.github.io/zh/posts/">文章</a></div>
    <h1 class="post-title entry-hint-parent">
      rCore 学习笔记2
    </h1>
    <div class="post-meta"><span title='2025-04-13 19:38:02 +0800 +0800'>四月 13, 2025</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;csmyx

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details >
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e5%9c%b0%e5%9d%80%e7%a9%ba%e9%97%b4%e9%9a%94%e7%a6%bb" aria-label="地址空间隔离">地址空间隔离</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%9c%ba%e5%88%b6" aria-label="实现机制">实现机制</a></li>
                    <li>
                        <a href="#%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84%e5%85%b3%e7%b3%bb" aria-label="地址映射关系">地址映射关系</a></li></ul>
                    </li>
                    <li>
                        <a href="#trap%e9%99%b7%e5%85%a5%e8%bf%87%e7%a8%8b" aria-label="trap陷入过程">trap陷入过程</a></li>
                    <li>
                        <a href="#trap%e8%bf%94%e5%9b%9e%e8%bf%87%e7%a8%8b" aria-label="trap返回过程">trap返回过程</a></li>
                    <li>
                        <a href="#%e7%9b%b8%e5%85%b3%e9%97%ae%e9%a2%98" aria-label="相关问题">相关问题</a></li>
                    <li>
                        <a href="#chapter4%e7%bb%83%e4%b9%a0" aria-label="chapter4练习">chapter4练习</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e5%86%85%e5%ae%b9" aria-label="实现内容">实现内容</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%a6%82%e8%a6%81" aria-label="实现概要">实现概要</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e9%97%ae%e7%ad%94%e4%bd%9c%e4%b8%9a" aria-label="问答作业">问答作业</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>
  <div class="post-content"><p>总结到chapter4的内容，练习和问答作业，重点是<code>地址空间隔离机制</code>的实现。</p>
<h3 id="地址空间隔离">地址空间隔离<a hidden class="anchor" aria-hidden="true" href="#地址空间隔离">#</a></h3>
<h4 id="实现机制">实现机制<a hidden class="anchor" aria-hidden="true" href="#实现机制">#</a></h4>
<p>[todo]</p>
<h4 id="地址映射关系">地址映射关系<a hidden class="anchor" aria-hidden="true" href="#地址映射关系">#</a></h4>
<p>一图流，秒了（画图画累了，写不动了，后面再补充文字描述吧[todo]）</p>
<img src="/img/2.png#center" style="zoom:67%;" />
<h3 id="trap陷入过程">trap陷入过程<a hidden class="anchor" aria-hidden="true" href="#trap陷入过程">#</a></h3>
<p>[todo]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__alltraps:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrrw</span> <span class="no">sp</span><span class="p">,</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">sp</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save other general purpose registers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># skip sp(x2), we will save it later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">sd</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># skip tp(x4), application does not use it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># save x5~x31
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="na">.rept</span> <span class="mi">27</span>
</span></span><span class="line"><span class="cl">        <span class="nf">SAVE_GP</span> <span class="nv">%n</span>
</span></span><span class="line"><span class="cl">        <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="na">.endr</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># we can use t0/t1/t2 freely, because they have been saved in TrapContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t0</span><span class="p">,</span> <span class="no">sstatus</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrr</span> <span class="no">t1</span><span class="p">,</span> <span class="no">sepc</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sd</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sd</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># read user stack from sscratch and save it in TrapContext
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrr</span> <span class="no">t2</span><span class="p">,</span> <span class="no">sscratch</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sd</span> <span class="no">t2</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># load kernel_satp into t0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">34</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># load trap_handler into t1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">36</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># move to kernel_sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">35</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># switch to kernel space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">satp</span><span class="p">,</span> <span class="no">t0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sfence.vma</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># jump to trap_handler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">jr</span> <span class="no">t1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>流程如下：</p>
<ul>
<li>
<p>1-22行：保存<code>trap context</code>（即当前所有寄存器的值）到用户栈上</p>
<p>当<code>trap</code>发生时，此时还处于用户空间，然后<code>sp</code>和<code>sscratch</code>分别指向用户栈顶和用户栈上的<code>trap context</code>。执行<code>csrrw</code>之后，<code>sp</code>指向了分配的<code>trap context</code>，然后就可以开始执行保存<code>trap context</code>的操作：就是执行一系列的<code>sd</code>操作，将寄存器的值保存到<code>sp</code>指向的<code>trap context</code>中。需要注意真正需要保存的<code>x2</code>（即<code>sp</code>）的值在<code>sscratch</code>中，需要特殊处理一下。</p>
</li>
<li>
<p>23-31 行：从用户空间切换到内核空间，跳转到<code>trap handler</code>执行</p>
<p>执行到 23 行时我们仍处于用户空间，具体来说，我们需要设置 3 个寄存器的值，这 3 个寄存器的值都从<code>trap context</code>中获取。</p>
<ol>
<li>设置<code>sp</code>寄存器，指向内核栈</li>
<li>设置<code>ra</code>寄存器，指向<code>trap handler</code></li>
<li>设置<code>stap</code>寄存器，指向内核空间（页表）的根地址，此时就切换到内核空间了</li>
</ol>
<p><strong>需要注意，由于这些寄存器的值是从用户栈上的获取，必须必须在第 30 行设置<code>stap</code>之前完成读取。</strong></p>
</li>
<li>
<p>32-33行：跳到trap_handler，<strong>这里使用jump register 而不是像第二章时直接call trap_handler，是因为后者是根据相对虚拟地址来跳转，而前者是根据绝对虚拟地址。开启MMU后，由于我们的trampline和实际物理地址不是直接映射，所以相对虚拟地址就不对了</strong></p>
<p>完成设置之后，就可以跳转到<code>trap handler</code>，在内核地址空间里	处理<code>trap</code>了</p>
</li>
</ul>
<p>以上流程的正确执行需要如下<strong>Preconditions</strong>：</p>
<ol>
<li>已经在用户栈上分配了<code>trap context</code>的空间，且其中保存了3个重要的值：内核栈地址、<code>trap handler</code>地址、<strong>内核空间根页表物理地址</strong></li>
<li><code>sp</code>指向用户栈顶，<code>sscratch</code>指向用户栈上的<code>trap context</code></li>
</ol>
<p>然后执行之后存在如下<strong>Postconditions</strong>：</p>
<ol>
<li>处于内核地址空间</li>
<li><code>sp</code>指向内核栈顶</li>
<li>用户进程的<code>trap context</code>已经保存到了用户栈上，且<code>sscratch</code>指向用户栈顶</li>
</ol>
<h3 id="trap返回过程">trap返回过程<a hidden class="anchor" aria-hidden="true" href="#trap返回过程">#</a></h3>
<p>[todo]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">__restore:</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># a0: *TrapContext in user space(Constant); a1: user space token
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># switch to user space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">csrw</span> <span class="no">satp</span><span class="p">,</span> <span class="no">a1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sfence.vma</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrw</span> <span class="no">sscratch</span><span class="p">,</span> <span class="no">a0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mv</span> <span class="no">sp</span><span class="p">,</span> <span class="no">a0</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># now sp points to TrapContext in user space, start restoring based on it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1"># restore sstatus/sepc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">t0</span><span class="p">,</span> <span class="mi">32</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ld</span> <span class="no">t1</span><span class="p">,</span> <span class="mi">33</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrw</span> <span class="no">sstatus</span><span class="p">,</span> <span class="no">t0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">csrw</span> <span class="no">sepc</span><span class="p">,</span> <span class="no">t1</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># restore general purpose registers except x0/sp/tp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">x1</span><span class="p">,</span> <span class="mi">1</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ld</span> <span class="no">x3</span><span class="p">,</span> <span class="mi">3</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="na">.rept</span> <span class="mi">27</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LOAD_GP</span> <span class="nv">%n</span>
</span></span><span class="line"><span class="cl">        <span class="na">.set</span> <span class="no">n</span><span class="p">,</span> <span class="no">n</span><span class="err">+</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="na">.endr</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># back to user stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ld</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">2</span><span class="p">*</span><span class="mi">8</span><span class="p">(</span><span class="no">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sret</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>Preconditions:
<ol>
<li>a0 指向用户栈上的trap context，a1指向<strong>用户空间根页表物理地址</strong></li>
</ol>
</li>
<li>流程如下：
<ul>
<li>1-5行：切换回用户空间</li>
<li>6行：将a0保存到<code>sscratch</code></li>
<li>7行-23行：根据a0恢复trap context</li>
<li>24行：sret回到用户态（U mode）</li>
</ul>
</li>
<li>Postconditions：
<ol>
<li><code>sscratch</code>指向用户栈上的<code>trap context</code></li>
<li>处于用户地址空间</li>
<li>已经根据trap context重置了寄存器状态</li>
</ol>
</li>
</ol>
<h3 id="相关问题">相关问题<a hidden class="anchor" aria-hidden="true" href="#相关问题">#</a></h3>
<p>以下问题是我个人学习过程中的遇到的几个困惑点，以及思考后得出来的答案，类似于官方的问答作业吧。如果这些问题你都能答得上来的话，说明本章的内容你掌握的很好了。（当然答案都是我的个人理解，如果有误，欢迎指正）</p>
<ol>
<li>
<p>假设存在N个app，此时有几个页表？有几个虚拟页同时映射到<code>trampoline</code>这个物理页？</p>
<p>答：朴素的答案是<code>N+1</code>，<code>N+2</code>。考虑系统调用时，会通过<code>PageTable::from_token</code>，构造一个临时页表用于访问用户空间，但是该临时页表其实也是复用的用户页表的根页表，所以不会影响答案。</p>
</li>
<li>
<p>为什么<code>call trap_handler</code>需要换成<code>jr t1</code>？为啥call只能是对pc的相对虚拟地址调整，而不能是直接对pc赋值为绝对虚拟地址？</p>
<p>答：原因和地址长度及指令长度相关。</p>
</li>
<li>
<p>如果我使用<code>call trap_handler</code>，是否有可能能够正常执行？如果去掉<code>.text.trampoline</code>之后的align(4K)之后，有没有可能呢？如果在内核态出错（比如<code>call trap_handler</code>导致出错）会发生什么情况</p>
</li>
<li>
<p>为啥需要在用户空间专门分配一个页面来保存<code>trap context</code>，而不是继续保存在内核栈上？</p>
<p>答：因为只有一个备用寄存器<code>sscratch</code>，无法同时保存<code>satp</code>和<code>kernel_stack_top</code>的值。于是我们统一将<code>satp</code>和<code>kernel_stack_top</code>的值保存用户页面上中，然后<code>scratch</code>保存该页面的地址即可通过<code>sscratch</code>同时获取这两个值了。</p>
</li>
<li>
<p>为啥需要 <code>set_kernel_trap_entry</code>和 <code>set_user_trap_entry</code>？</p>
</li>
<li>
<p>在用户态执行时（陷入内核之前），<code>sscratch</code>的值是啥？</p>
<p>答：始终等于<code>TRAP_CONTEXT_BASE</code>。</p>
</li>
<li>
<p><code>trap_context</code>中有哪些变量是用于读的，哪些是用于写的？用于读的的变量的值在初始化之后会被修改吗？</p>
<p>答：<code>kernel_stap</code>, <code>kernel_sp</code>, <code>trap_handler</code>是用于读的，其余是用于写的。<strong>其中kernel_satp和kernel_sp在初始化之后保持不变</strong>，而<code>trap_handler</code>在进入<code>trap_handler</code>时会被设置成<code>trap_from_kernel</code>，而在进入<code>trap_return</code>时会被设置回<code>TRAMPOLINE</code>。</p>
</li>
</ol>
<h3 id="chapter4练习">chapter4练习<a hidden class="anchor" aria-hidden="true" href="#chapter4练习">#</a></h3>
<h4 id="实现内容">实现内容<a hidden class="anchor" aria-hidden="true" href="#实现内容">#</a></h4>
<ul>
<li>重写 <code>sys_get_time</code> 和 <code>sys_trace</code></li>
<li>实现<code>mmap</code> 和 <code>munmap</code></li>
</ul>
<h4 id="实现概要">实现概要<a hidden class="anchor" aria-hidden="true" href="#实现概要">#</a></h4>
<p>以下是一些重要注意事项（待完善，[todo]）</p>
<ul>
<li>
<p><code>PageTable::from_token</code>只是用于<code>trap</code>后处于内核空间时，通过该<code>token</code>临时构造一个用于查询用户内存空间的页表，该页表不会被赋值给<code>satp</code>，不进行实际的地址转换作用，不负责管理用户帧的分配回收，<code>frames</code>置为空。</p>
<p>而在<code>sys_mmap</code>中涉及到分配<code>frame</code>之后，就不再能够使用<code>PageTable::from_token</code>临时构造页表了，而是直接使用用户空间的原始内核页表，而且光使用页表也是不够的，需要直接调用 <strong><code>memory_set</code>的<code>insert_framed_area</code></strong> 方法添加一个<code>map_area</code>。</p>
</li>
<li>
<p>尝试构造非法虚拟地址，看调用<code>sys_get_time</code>或<code>sys_trace</code>是否符合预期，返回 -1</p>
</li>
<li>
<p>为啥测试用例调用 4 次<code>get_time</code>，但只是<code>assert(3 &lt;= count(sys_get_time))</code>?</p>
</li>
<li>
<p><strong>页表标志位用法</strong>：最低一级页表的<code>pte</code>，除了<code>V</code>标志位以外，<code>RWXU</code>标志位也有效（因为<code>pte</code>中存的是物理帧地址），而其它级别页表由于<code>pte</code>中存的是下一级的页表的物理地址，所以只有<code>V</code>标志位有用。而且有一个细节，最低一级页表的<code>pte</code>的标志位是在<code>PageTable::map</code>中完成的，而其它级别页表的<code>pte</code>的标志位是在<code>PageTable::find_pte_create</code>中设置的。</p>
<p>最低一级页表的<code>RWXU</code>标志位是根据逻辑段<code>MapArea</code>的<code>map permission</code>来设置，<strong>因此用户可访问权限的逻辑段的初始化，一定要赋予该<code>U</code>权限。</strong></p>
<img src="/img/3.png#center" style="zoom:67%;" />
<p>与该标志位设置相关的bugfix：</p>
<img src="/img/4.png#center" style="zoom:67%;" />
<img src="/img/5.png#center" style="zoom:67%;" />
<h3 id="问答作业">问答作业<a hidden class="anchor" aria-hidden="true" href="#问答作业">#</a></h3>
<ol>
<li>
<p>请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？</p>
<p>答：页表项总共64位，可以这样记：高10位为保留字段，低10位为标志位，中间44位为物理页号.</p>
<p>其中各个标志位的作用为：</p>
<ul>
<li>V: 页表项是否合法</li>
<li>R/W/X：对该页表项所指向的物理页面是否有读/写/执行权限。（参看实现概要中我的思考，这些字段仅针对第三级页表项）</li>
<li>U：是否允许 CPU 在处于 U 特权级时访问该页表项所指向的物理页面</li>
<li>A：自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过</li>
<li>D：自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过</li>
</ul>
</li>
<li>
<p>缺页</p>
<p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。</p>
<ul>
<li>
<p>请问哪些异常可能是缺页导致的？</p>
<p>答：[todo]</p>
</li>
<li>
<p>发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</p>
</li>
</ul>
<p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</p>
<ul>
<li>这样做有哪些好处？</li>
</ul>
<p>其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p>
<ul>
<li>处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</li>
<li>请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</li>
</ul>
<p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</p>
<ul>
<li>此时页面失效如何表现在页表项(PTE)上？</li>
</ul>
</li>
<li>
<p>双页表与单页表</p>
<p>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a> )</p>
<ul>
<li>在单页表情况下，如何更换页表？</li>
<li>单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）</li>
<li>单页表有何优势？（回答合理即可）</li>
<li>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</li>
</ul>
</li>
</ol>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/csmyx/csmyx.github.io">csmyx</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
