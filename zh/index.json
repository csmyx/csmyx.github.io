[{"content":"记录一次git clone异常的网络问题排查经历和总结。\nwsl2 网络问题排查 最近我在写rcore的实现，昨天突然发现，我在wsl2里clone代码时无法通过ssh认证了：\n1 git clone git@github.com:LearningOS/rCore-Tutorial-Checker-2025S ci-user 明明是一次正常的clone代码操作，突然提示我输入密码，给我搞蒙了，我寻思我不是ssh方式clone的吗，为啥还要输入密码，关键我也没设置过哇。然后我又拿我自己的另一个仓库试了试，如下图所示，还是一样：\n为啥会提示输入密码呢，我查了一下，发现其实github ssh方式是可以在非对称加密之外，再额外配置一个密码，，其作用就是在私钥泄露之后还有一道防线。当然这个是可选项，也可以选择不配置。\n具体用法是，当你生成ssh密钥时，会提示是否设置密码，但是这里一般都是回车跳过选择不配置，所以我对这个没啥印象。。\n那么问题来了，既然我都没配置密码，为啥还会提示我输入密码？显然这时无论我输入什么都没用。接下来就是实际排查过程了\n排查过程 利用ssh -vT git@github.com，加上-v参数查看调试信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ❯ ssh -vT git@github.com OpenSSH_8.9p1 Ubuntu-3ubuntu0.11, OpenSSL 3.0.2 15 Mar 2022 debug1: Reading configuration data /etc/ssh/ssh_config debug1: /etc/ssh/ssh_config line 19: include /etc/ssh/ssh_config.d/*.conf matched no files debug1: /etc/ssh/ssh_config line 21: Applying options for * debug1: Connecting to github.com [::1] port 22. debug1: Connection established. debug1: identity file /home/hugo/.ssh/id_rsa type -1 debug1: identity file /home/hugo/.ssh/id_rsa-cert type -1 debug1: identity file /home/hugo/.ssh/id_ecdsa type -1 debug1: identity file /home/hugo/.ssh/id_ecdsa-cert type -1 debug1: identity file /home/hugo/.ssh/id_ecdsa_sk type -1 debug1: identity file /home/hugo/.ssh/id_ecdsa_sk-cert type -1 debug1: identity file /home/hugo/.ssh/id_ed25519 type 3 debug1: identity file /home/hugo/.ssh/id_ed25519-cert type -1 debug1: identity file /home/hugo/.ssh/id_ed25519_sk type -1 debug1: identity file /home/hugo/.ssh/id_ed25519_sk-cert type -1 debug1: identity file /home/hugo/.ssh/id_xmss type -1 debug1: identity file /home/hugo/.ssh/id_xmss-cert type -1 debug1: identity file /home/hugo/.ssh/id_dsa type -1 debug1: identity file /home/hugo/.ssh/id_dsa-cert type -1 debug1: Local version string SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.11 debug1: Remote protocol version 2.0, remote software version OpenSSH_8.9p1 Ubuntu-3ubuntu0.11 debug1: compat_banner: match: OpenSSH_8.9p1 Ubuntu-3ubuntu0.11 pat OpenSSH* compat 0x04000000 debug1: Authenticating to github.com:22 as \u0026#39;git\u0026#39; debug1: load_hostkeys: fopen /home/hugo/.ssh/known_hosts2: No such file or directory debug1: load_hostkeys: fopen /etc/ssh/ssh_known_hosts: No such file or directory debug1: load_hostkeys: fopen /etc/ssh/ssh_known_hosts2: No such file or directory debug1: SSH2_MSG_KEXINIT sent debug1: SSH2_MSG_KEXINIT received debug1: kex: algorithm: curve25519-sha256 debug1: kex: host key algorithm: ssh-ed25519 debug1: kex: server-\u0026gt;client cipher: chacha20-poly1305@openssh.com MAC: \u0026lt;implicit\u0026gt; compression: none debug1: kex: client-\u0026gt;server cipher: chacha20-poly1305@openssh.com MAC: \u0026lt;implicit\u0026gt; compression: none debug1: expecting SSH2_MSG_KEX_ECDH_REPLY debug1: SSH2_MSG_KEX_ECDH_REPLY received debug1: Server host key: ssh-ed25519 SHA256:9Hm0FgEIUF+vuwAJS3i3cP0t7iMWmvdsjWI9Xj6SkFM debug1: load_hostkeys: fopen /home/hugo/.ssh/known_hosts2: No such file or directory debug1: load_hostkeys: fopen /etc/ssh/ssh_known_hosts: No such file or directory debug1: load_hostkeys: fopen /etc/ssh/ssh_known_hosts2: No such file or directory debug1: Host \u0026#39;github.com\u0026#39; is known and matches the ED25519 host key. debug1: Found key in /home/hugo/.ssh/known_hosts:1 debug1: ssh_packet_send2_wrapped: resetting send seqnr 3 debug1: rekey out after 134217728 blocks debug1: SSH2_MSG_NEWKEYS sent debug1: expecting SSH2_MSG_NEWKEYS debug1: ssh_packet_read_poll2: resetting read seqnr 3 debug1: SSH2_MSG_NEWKEYS received debug1: rekey in after 134217728 blocks debug1: get_agent_identities: bound agent to hostkey debug1: get_agent_identities: ssh_fetch_identitylist: agent contains no identities debug1: Will attempt key: /home/hugo/.ssh/id_rsa debug1: Will attempt key: /home/hugo/.ssh/id_ecdsa debug1: Will attempt key: /home/hugo/.ssh/id_ecdsa_sk debug1: Will attempt key: /home/hugo/.ssh/id_ed25519 ED25519 SHA256:2VCfJ2gt7esKRuryTwGbO8FeU0xHUT6/yUWci2kt5nE debug1: Will attempt key: /home/hugo/.ssh/id_ed25519_sk debug1: Will attempt key: /home/hugo/.ssh/id_xmss debug1: Will attempt key: /home/hugo/.ssh/id_dsa debug1: SSH2_MSG_EXT_INFO received debug1: kex_input_ext_info: server-sig-algs=\u0026lt;ssh-ed25519,sk-ssh-ed25519@openssh.com,ssh-rsa,rsa-sha2-256,rsa-sha2-512,ssh-dss,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ecdsa-sha2-nistp256@openssh.com,webauthn-sk-ecdsa-sha2-nistp256@openssh.com\u0026gt; debug1: kex_input_ext_info: publickey-hostbound@openssh.com=\u0026lt;0\u0026gt; debug1: SSH2_MSG_SERVICE_ACCEPT received debug1: Authentications that can continue: publickey,password debug1: Next authentication method: publickey debug1: Trying private key: /home/hugo/.ssh/id_rsa debug1: Trying private key: /home/hugo/.ssh/id_ecdsa debug1: Trying private key: /home/hugo/.ssh/id_ecdsa_sk debug1: Offering public key: /home/hugo/.ssh/id_ed25519 ED25519 SHA256:2VCfJ2gt7esKRuryTwGbO8FeU0xHUT6/yUWci2kt5nE debug1: Authentications that can continue: publickey,password debug1: Trying private key: /home/hugo/.ssh/id_ed25519_sk debug1: Trying private key: /home/hugo/.ssh/id_xmss debug1: Trying private key: /home/hugo/.ssh/id_dsa debug1: Next authentication method: password git@github.com\u0026#39;s password: 发现认证过程是先是尝试publickey然后再尝试password的。所以，问题就是出在我们公钥认证没通过，所以才提示我们用密码验证。接下来就是排查为啥公钥方式错误。\n公钥认证错误 以下常见的几个问题我都检查过，没有任何问题：\n密钥类型不能是旧版rsa github配置过程问题 文件权限问题 既然和ssh密钥配置过程没问题，接下来我怀疑是网络配置的问题。\nWSL2网络配置和代理问题 我首先怀疑的是wsl的镜像网络模式和我的clash 代理的协同有问题。之前我用的是wsl的NAT模式，改成镜像网络模式之后，WSL2与Windows宿主机共享一个局域网IP，localhost也指向一个，所以现在无需配置，就会走宿主机的clash代理了，理论上来说没问题，之前也用的好好的。而且这个是否走宿主机的系统代理也是有一个参数autoProxy=true可以在.wslconfig 里配置的，实际上这就是和我之前用NAT模式时需要手动配置http_proxy指向clash代理的ip和端口一样的，只是现在改成镜像网络之后，系统会自动帮我配置好了。\n所以排除是代理的问题，但是既然不是代理的问题\nclash代理的TUN配置 这个tun模式很强大，根据这篇文章，我理解他的作用是实现和wsl镜像模式类似的作用，而且更强大，等于是虚拟了一个接口，不仅代理了http，连底层的比如ping命令的icmp协议等都能代理。但是无论我是否开启tun，问题都存在，应该和这个没关系。\nssh配置问题 我之前根据Using SSH over the HTTPS port，配置过~/.ssh/config ，使用443端口来转发SSH而不是默认22端口。\n1 2 3 4 5 ❯ cat ~/.ssh/config Host github.com Hostname ssh.github.com Port 443 User git 我推测这应该是之前用wsl的NAT网络模式时遇到问题配置的，我将他去掉，也没有作用。\n域名解析问题 下面这个错误让我定位到了真正问题所在。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ ssh -vT git@github.com @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ED25519 key sent by the remote host is SHA256:9Hm0FgEIUF+vuwAJS3i3cP0t7iMWmvdsjWI9Xj6SkFM. Please contact your system administrator. Add correct host key in /home/hugo/.ssh/known_hosts to get rid of this message. Offending RSA key in /home/hugo/.ssh/known_hosts:3 remove with: ssh-keygen -f \u0026#34;/home/hugo/.ssh/known_hosts\u0026#34; -R \u0026#34;github.com\u0026#34; Host key for github.com has changed and you have requested strict checking. Host key verification failed. 当我第一次尝试ssh -T git@github.com命令，会打印了一个warning，提示fingerprint发生变化。fingerprint就是网站指纹，简单来说就是用来验证访问网站身份的，防止中间人攻击。\n~/.ssh/known_hosts文件与这个有关，该文件里保存之前通过验证的网站，这里会打印warning就是说明我当前访问的网站的fingerprint和历史认证不一致。我查了一下，github他的fingerprint都是可以在这里查到的，我这里的和官网给的居然真的对不上。。。\nwtf，难不成我还真遭遇了中间人攻击，登录到了假的github？\n仔细想了下，显然是我们的域名解析有问题。查了一下域名服务器配置文件/etc/resolv.conf：\n1 2 3 4 5 # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf: # [network] # generateResolvConf = false nameserver 10.255.255.254 search lan 这也是wsl镜像模式自动配置的，namerserver的ip其实就是宿主机的ip，就是说域名解析是跟宿主机一样的。\n诡异的地方来了，为啥域名解析结果是127.0.0.1?\n白丝不得其解时，我发现，我的windows宿主机里的C:\\Users\\xxx\\.ssh\\config配置了这个：\n1 2 3 4 5 6 7 8 9 //socks5 Host github.com User git ProxyCommand connect -S 127.0.0.1:7891 %h %p //http || https Host github.com User git ProxyCommand connect -H 127.0.0.1:7891 %h %p 最终破案，就是因为我的宿主机里配置了，github走本地代理的127.0.0.1:7891，而wsl开启镜像模式之后，又是用的宿主机作为域名服务器，所以最后导致域名解析github.com时会变成127.0.0.1。(其实一开始git clone时提示信息里就显示了域名解析成了::1，只是我没注意。\n这个配置应该是我之前在windows上clone代码时发现没走代理配置的，应该是随便参考的类似这样的文章，好像是为了在windows上绕过 ssh 防火墙限制 。我不太清楚这个配置现在是否还有作用，但是这个就是问题根源，我也懒得改了，先不管windows了，至于这为啥会导致fingerprint发生变化，我也不太清楚。累了，先解决问题吧。\n我的方案是，修改wsl的域名解析不走宿主机，这样也不用改宿主机的里的~/.ssh\\config文件。测试了一下将wsl里的域名服务器改成不用自动生成的宿主机的ip，而是用114.114.114.114，域名解析也正常了，然后github公钥认证问题也没有了。\n下图所示，对比使用宿主机和114.114.114.114两者域名解析的结果：\n所以修改方案就是不要让wsl帮我们配置域名，而是我们自己配置。\n修改方案 按上文所示，手动配置DNS，在/etc/resolv.conf设置\n1 2 3 4 5 6 7 ❯ cat /etc/resolv.conf # This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf: # [network] # generateResolvConf = false nameserver 114.114.114.114 nameserver 8.8.8.8 search lan 按上面文件内提示，示在 /etc/wsl.conf中添加generateResolvConf = false设置\n1 2 3 4 5 6 7 ❯ cat /etc/wsl.conf [boot] systemd=true [network] generateResolvConf = false 但是上面这样配置之后，在wsl重启之后，/etc/resolv.conf没了，不会自动生成。所以需要我们手动再设置一遍，有点吗。这个以后再折腾吧。可参考这篇文章\nOK，问题解决了，我继续去写我的rcore实现了。\nTakeaway fingerprint 用于验证网站正确性，防止中间人攻击。~/.ssh/known_hosts保存着通过认证的网站信息\nwsl2镜像网络模式 如何让WSL2全局(包括ping)走Clash的HTTP代理\nclash代理的tun模式 在 WSL2 中使用 Clash for Windows 代理连接\n域名解析配置 Linux服务器配置DNS解析 查询域名解析命令：nslookup 域名 [DNS服务器IP]\n参考链接 About passphrases for SSH keys\n如何让WSL2全局(包括ping)走Clash的HTTP代理\nWindows配置git代理\n通过 HTTPS 端口使用 SSH，绕过代理防火墙\nWSL2的镜像网络模式\n在 WSL2 中使用 Clash for Windows 代理连接\nLinux服务器配置DNS解析 ","permalink":"https://csmyx.github.io/zh/posts/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/note1/","summary":"系列: 网络问题","title":"git clone异常问题排查"},{"content":" ","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/","summary":"系列: rCore-Camp-Guide-2025S","title":"rCore 学习笔记3"},{"content":"总结到chapter4的内容，练习和问答作业，重点是地址空间隔离机制的实现。\n地址空间隔离 实现机制 [todo]\n地址映射关系 一图流，秒了（画图画累了，写不动了，后面再补充文字描述吧[todo]）\ntrap陷入过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 __alltraps: csrrw sp, sscratch, sp # now sp-\u0026gt;*TrapContext in user space, sscratch-\u0026gt;user stack # save other general purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they have been saved in TrapContext csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it in TrapContext csrr t2, sscratch sd t2, 2*8(sp) # load kernel_satp into t0 ld t0, 34*8(sp) # load trap_handler into t1 ld t1, 36*8(sp) # move to kernel_sp ld sp, 35*8(sp) # switch to kernel space csrw satp, t0 sfence.vma # jump to trap_handler jr t1 流程如下：\n1-22行：保存trap context（即当前所有寄存器的值）到用户栈上\n当trap发生时，此时还处于用户空间，然后sp和sscratch分别指向用户栈顶和用户栈上的trap context。执行csrrw之后，sp指向了分配的trap context，然后就可以开始执行保存trap context的操作：就是执行一系列的sd操作，将寄存器的值保存到sp指向的trap context中。需要注意真正需要保存的x2（即sp）的值在sscratch中，需要特殊处理一下。\n23-31 行：从用户空间切换到内核空间，跳转到trap handler执行\n执行到 23 行时我们仍处于用户空间，具体来说，我们需要设置 3 个寄存器的值，这 3 个寄存器的值都从trap context中获取。\n设置sp寄存器，指向内核栈 设置ra寄存器，指向trap handler 设置stap寄存器，指向内核空间（页表）的根地址，此时就切换到内核空间了 需要注意，由于这些寄存器的值是从用户栈上的获取，必须必须在第 30 行设置stap之前完成读取。\n32-33行：跳到trap_handler，这里使用jump register 而不是像第二章时直接call trap_handler，是因为后者是根据相对虚拟地址来跳转，而前者是根据绝对虚拟地址。开启MMU后，由于我们的trampline和实际物理地址不是直接映射，所以相对虚拟地址就不对了\n完成设置之后，就可以跳转到trap handler，在内核地址空间里\t处理trap了\n以上流程的正确执行需要如下Preconditions：\n已经在用户栈上分配了trap context的空间，且其中保存了3个重要的值：内核栈地址、trap handler地址、内核空间根页表物理地址 sp指向用户栈顶，sscratch指向用户栈上的trap context 然后执行之后存在如下Postconditions：\n处于内核地址空间 sp指向内核栈顶 用户进程的trap context已经保存到了用户栈上，且sscratch指向用户栈顶 trap返回过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 __restore: # a0: *TrapContext in user space(Constant); a1: user space token # switch to user space csrw satp, a1 sfence.vma csrw sscratch, a0 mv sp, a0 # now sp points to TrapContext in user space, start restoring based on it # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) csrw sstatus, t0 csrw sepc, t1 # restore general purpose registers except x0/sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # back to user stack ld sp, 2*8(sp) sret Preconditions: a0 指向用户栈上的trap context，a1指向用户空间根页表物理地址 流程如下： 1-5行：切换回用户空间 6行：将a0保存到sscratch 7行-23行：根据a0恢复trap context 24行：sret回到用户态（U mode） Postconditions： sscratch指向用户栈上的trap context 处于用户地址空间 已经根据trap context重置了寄存器状态 相关问题 以下问题是我个人学习过程中的遇到的几个困惑点，以及思考后得出来的答案，类似于官方的问答作业吧。如果这些问题你都能答得上来的话，说明本章的内容你掌握的很好了。（当然答案都是我的个人理解，如果有误，欢迎指正）\n假设存在N个app，此时有几个页表？有几个虚拟页同时映射到trampoline这个物理页？\n答：朴素的答案是N+1，N+2。考虑系统调用时，会通过PageTable::from_token，构造一个临时页表用于访问用户空间，但是该临时页表其实也是复用的用户页表的根页表，所以不会影响答案。\n为什么call trap_handler需要换成jr t1？为啥call只能是对pc的相对虚拟地址调整，而不能是直接对pc赋值为绝对虚拟地址？\n答：原因和地址长度及指令长度相关。\n如果我使用call trap_handler，是否有可能能够正常执行？如果去掉.text.trampoline之后的align(4K)之后，有没有可能呢？如果在内核态出错（比如call trap_handler导致出错）会发生什么情况\n为啥需要在用户空间专门分配一个页面来保存trap context，而不是继续保存在内核栈上？\n答：因为只有一个备用寄存器sscratch，无法同时保存satp和kernel_stack_top的值。于是我们统一将satp和kernel_stack_top的值保存用户页面上中，然后scratch保存该页面的地址即可通过sscratch同时获取这两个值了。\n为啥需要 set_kernel_trap_entry和 set_user_trap_entry？\n在用户态执行时（陷入内核之前），sscratch的值是啥？\n答：始终等于TRAP_CONTEXT_BASE。\ntrap_context中有哪些变量是用于读的，哪些是用于写的？用于读的的变量的值在初始化之后会被修改吗？\n答：kernel_stap, kernel_sp, trap_handler是用于读的，其余是用于写的。其中kernel_satp和kernel_sp在初始化之后保持不变，而trap_handler在进入trap_handler时会被设置成trap_from_kernel，而在进入trap_return时会被设置回TRAMPOLINE。\nchapter4练习 实现内容 重写 sys_get_time 和 sys_trace 实现mmap 和 munmap 实现概要 以下是一些重要注意事项（待完善，[todo]）\nPageTable::from_token只是用于trap后处于内核空间时，通过该token临时构造一个用于查询用户内存空间的页表，该页表不会被赋值给satp，不进行实际的地址转换作用，不负责管理用户帧的分配回收，frames置为空。\n而在sys_mmap中涉及到分配frame之后，就不再能够使用PageTable::from_token临时构造页表了，而是直接使用用户空间的原始内核页表，而且光使用页表也是不够的，需要直接调用 memory_set的insert_framed_area 方法添加一个map_area。\n尝试构造非法虚拟地址，看调用sys_get_time或sys_trace是否符合预期，返回 -1\n为啥测试用例调用 4 次get_time，但只是assert(3 \u0026lt;= count(sys_get_time))?\n页表标志位用法：最低一级页表的pte，除了V标志位以外，RWXU标志位也有效（因为pte中存的是物理帧地址），而其它级别页表由于pte中存的是下一级的页表的物理地址，所以只有V标志位有用。而且有一个细节，最低一级页表的pte的标志位是在PageTable::map中完成的，而其它级别页表的pte的标志位是在PageTable::find_pte_create中设置的。\n最低一级页表的RWXU标志位是根据逻辑段MapArea的map permission来设置，因此用户可访问权限的逻辑段的初始化，一定要赋予该U权限。\n与该标志位设置相关的bugfix：\n问答作业 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？\n答：页表项总共64位，可以这样记：高10位为保留字段，低10位为标志位，中间44位为物理页号.\n其中各个标志位的作用为：\nV: 页表项是否合法 R/W/X：对该页表项所指向的物理页面是否有读/写/执行权限。（参看实现概要中我的思考，这些字段仅针对第三级页表项） U：是否允许 CPU 在处于 U 特权级时访问该页表项所指向的物理页面 A：自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过 D：自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过 缺页\n缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。\n请问哪些异常可能是缺页导致的？\n答：[todo]\n发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。\n缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\n这样做有哪些好处？ 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？ 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\n此时页面失效如何表现在页表项(PTE)上？ 双页表与单页表\n为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n在单页表情况下，如何更换页表？ 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问） 单页表有何优势？（回答合理即可） 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ ","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","summary":"系列: rCore-Camp-Guide-2025S，对应文档第4章的内容","title":"rCore 学习笔记2"},{"content":"总结chapter3的内容，相关练习和简答作业。\n实现解读 参考[rCore-Camp-Guide-2025S 文档，我对ch3分支的新增代码实现的个人解读。\n多道程序加载 链接地址和加载地址 在说明多道程序加载的实现之前，我们现说明一下两个概念：\n链接地址：即程序编译链接后二进制文件中的地址。\n加载地址：即程序在加载到内存中实际执行时的地址。\nok，然后我们再来说多道程序加载，第二章实现的是一个批处理系统，该系统一次只会加载一个用户程序，每次需要执行下个程序时，再加载指定用户程序。而多道程序加载就是说，内核在初始化的时候就将多个用户程序同时加载到了其指定执行地址，这时就要求每个用户程序的加载地址必须不同了，否则不就可能发生覆盖了嘛。\n这就是我们需要解决的问题：即保证每个用户程序有不同的加载地址。朴素的做法，就是给每个用户程序指定一个起始地址偏移即可。\n在第四章之前，kernel还没有实现地址空间隔离机制，此时用户程序的加载地址等于其链接地址。所以，如果用户程序的加载地址不同，就需要用户程序的链接地址也不同。\n接下来，就看我们是怎么控制链接地址和装载地址，来解决多道程序加载引入的地址冲突问题的。\n链接过程 用户程序的链接地址，自然是要去看user/目录下各个用户程序二进制文件是怎么构建出来的，该过程由build.py脚本来控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # user/build.py for app in apps: app = app[: app.find(\u0026#34;.\u0026#34;)] os.system( \u0026#34;cargo rustc --bin %s %s -- -Clink-args=-Ttext=%x\u0026#34; % (app, mode_arg, base_address + step * app_id) ) print( \u0026#34;[build.py] application %s start with address %s\u0026#34; % (app, hex(base_address + step * app_id)) ) if chapter == \u0026#39;3\u0026#39;: app_id = app_id + 1 这里-Clink-arg=-Text=base_address + step * app_id指了定构建之后的代码段的起始地址。在链接脚本也能实现，只是这次通过给rustc传递编译参数的方式来实现，比较方便。\n这里关键就是13-14行，可以看出如果chapter2的话，每个用户的起始地址都是base_address。如果是chapter3，那么每个用户程序链接后会有一个step的地址偏移。只要我们保证step足够大，就能保证每个用户程序链接到不同的地址处，这就解决了链接地址的冲突。\n加载过程 再来看加载的过程，该过程通过load_apps控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /// Load nth user app at /// [APP_BASE_ADDRESS + n * APP_SIZE_LIMIT, APP_BASE_ADDRESS + (n+1) * APP_SIZE_LIMIT). pub fn load_apps() { extern \u0026#34;C\u0026#34; { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // load apps for i in 0..num_app { let base_i = get_base_i(i); // clear region (base_i..base_i + APP_SIZE_LIMIT) .for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // load app from data section to memory let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; dst.copy_from_slice(src); } } 其实现很自然，就是按照链接地址的约定，每个用户程序加载到不同的地址偏移处。（具体操作是，是从数据段复制到代码段的指定地址处，可参考note0 [todo]）\n总结 为每个用户程序引入了一个地址偏移，这样就保证了同时加载用户程序时，不会出现地址冲突。\n分时多任务 基于时间片轮转。\n[todo]\nchapter3练习 实现内容 实现系统调用sys_trace，该系统调用的作用是获取当前任务的系统调用的历史信息，该系统调用接口如下：\n1 fn sys_trace(trace_request: usize, id: usize, data: usize) -\u0026gt; isize 具体来说，其作用根据参数trace_request的值细分为3种：\n0：读指定地址 1：写指定地址 2：查询指定系统调用被调用过的次数 实现概要 这是我的个人实现的思考过程，不涉及具体代码实现，只提供一些思路拓展或注意事项。\ntrace_request=0、1 就是读写指定地址变量，实现很自然（chapter4 引入地址空间隔离之后，读写也会变的麻烦）\ntrace_request=2 的请求需要注意，这一次调用也计入统计。所以我们更新系统调用次数的处理逻辑需要在 sys_call 开头处，在分发系统调用逻辑之前实现。\n那么统计次数用什么数据结构来记录维护呢？很自然的想到用 HashMap，但是 HashMap 是 std 中的实现，所以我们没法用。那只能用线性容器了，毕竟系统调用的个数不多，线性查找可以接受。为了简单起见，直接用定长数组即可（其实也可以用 Vec，因为初始化时已经 init_heap 了，所以可以使用堆容器 Vec）。\n我将这个定长数组命名为 syscall_counter，显然数组元素为一个系统调用号到计数的 k-v 键值对即可，而数组长度如何确定呢，我的实现是新增了一个包含所有系统调用号的常量数组 SYSCALL_ARRAY，基于该数组我们可以确定 syscall_counter 的长度，以及数组元素需要包含的所有 key 信息。\n所以我们的syscall_counter的类型定义为：[(usize, usize); SYSCALL_ARRAY.len()]。\n确定好了数据结构，具体这个 syscall_counter 保存放在哪里呢？需要注意，系统调用次数查询是针对当前任务的，也就是说每个任务系统调用的次数统计是独立的，所以我们将 syscall_counter 放在 task manager 中。自然，初始化的逻辑就放在初始化 task manager 的 lazy_static 宏中。\n然后就是统计信息更新过程，就如上文所说，需要放在 sys_call 开头，线性查找到指定 key 将 value 自增 1 即可。最后，我们查找 syscall_counter 中给定 key 的 value，即可实现 sys_trace 的查询功能。\n当读第4章代码时，我发现我们的syscall_counter其实也可以使用BTreeMap，这玩意定义是在core中而不是在std中。\n问答作业 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 三个 bad 测例 (ch2b_bad_*.rs) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。\n答：运行命令：\n1 2 3 cd os git checkout ch3 make run LOG=INFO BASE=1 出错行为如下：\nch2b_bad_address：触发StorePageFault异常，在trap_handler中报错并退出执行 ch2b_bad_instructions：触发IllegalInstruction异常，在trap_handler中报错并退出执行 ch2b_bad_register：触发IllegalInstruction异常，在trap_handler中报错并退出执行 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:\nL40：刚进入 __restore 时，sp 代表了什么值。请指出 __restore 的两种使用情景。\n答：sp此时保存着内核栈顶地址。[todo]\nL43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。\n1 2 3 4 5 6 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 L50-L56：为何跳过了 x2 和 x4？\n1 2 3 4 5 6 7 ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr 答：x2即sp，目前指向栈顶，需要设置完其它寄存器后再设置，即通过L60的csrrw sp, sscratch, sp来设置x2，x4是tp(Thread pointer)线程寄存器，暂时不需要设置。\nL60：该指令之后，sp 和 sscratch 中的值分别有什么意义？\n1 csrrw sp, sscratch, sp 答：执行后，sp指向用户栈，sscratch指向内核栈。\n__restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？\n答：L61行的srete发生状态切换。因为该指令会根据sstatus寄存器中的SPP标志位决定切换到什么状态，而SPP标志位在之前从用户态陷入内核态时，就被设置成了标志用户态。\nL13：该指令之后，sp 和 sscratch 中的值分别有什么意义？\n1 csrrw sp, sscratch, sp 答：执行后，sp指向内核栈，sscratch指向用户栈。\n从 U 态进入 S 态是哪一条指令发生的？\n答：ecall指令。\n","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","summary":"系列: rCore-Camp-Guide-2025S，对应文档第3章的内容","title":"rCore 学习笔记1"},{"content":"总结到chapter0到chapter2中的重要内容。\n内核初始化过程 相关文件 os/src/entry.asm\nos/src/link_app.S\nos/src/main.rs\n具体过程 1 2 3 4 5 6 7 pub fn rust_main() -\u0026gt; ! { clear_bss(); logging::init(); trap::init(); batch::init(); batch::run_next_app(); } [todo]\n构建运行过程 相关文件 os/Makefile user/Makefile user/build.py 构建（build） 1 2 3 4 5 6 7 8 9 10 11 12 build: env $(KERNEL_BIN) env: (rustup target list | grep \u0026#34;riscv64gc-unknown-none-elf (installed)\u0026#34;) || rustup target add $(TARGET) cargo install cargo-binutils rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @echo Platform: $(BOARD) @cargo build $(MODE_ARG) 即构建可执行的内核二进制文件KERNEL_BIN，这玩意就是我们需要构建的目标产物，就是我们的kernel的实体，或者说叫内核镜像吧。\n构建过程如下：\nenv：测试构建环境\nkernel：进入到../user目录执行make build命令，构建用户程序文件。再执行cargo build命令build二进制文件。这里是关键。构建出来的用户程序二进制文件到底是怎么和内核二进制文件关联起来的呢？就是通过如下这行代码，执行了link_app.S中的汇编代码：\n1 2 // os/src/main.rs global_asm!(include_str!(\u0026#34;link_app.S\u0026#34;)); 而link_app.S中的代码做的事情就是，将用户的二进制程序文件映射到内核二进制的数据段中。同时还生成了_num_app、app_0_start、app_0_end等符号，这样rust代码就可以利用这些符号找到各个用户程序的二进制了，需要运行某个用户程序时，就通过这些符号找到数据段中的指定用户程序的代码，将其复制到代码段中就可以执行了，该过程的具体代码查看load_app函数（该函数实现方式在chapter2和chapter3中有所不同，具体请看note2中的加载过程章节[todo] ）。\n$(KERNEL_BIN)：--strip-all去除多余信息，生成最终的镜像。\n运行（run） 1 2 3 4 5 @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) 即运行qemu跑我们的内核，需要指定若干参数：\nfile=：指定的需要加载运行的内核镜像路径，即我们上面说的KERNEL_BIN。 addr=：指定内核加载地址。 链接过程 相关文件 os/src/linker.ld 具体过程 编译链接之后，程序中的每个变量符号被替换成了具体的地址值（不清楚的参考csapp相关章节）。\n一般来说，我们不需要关心具体的地址值是多少，交给链接器来决定就好。上层应用不关心变量的具体地址，只要别把不同变量映射到同个地址就行。\n但是们在链接内核二进制时，就需要关心了，比如设定各个段的加载地址，加载顺序，地址对齐等，主要包括text、rodata、data、bss这四个段。同时也添加一些符号，比如stext，etext来标记代码段的起始地址和终止地址。\n所以总结，链接脚本的作用就是控制链接后的二进制文件的地址空间布局。\n","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/","summary":"系列: rCore-Camp-Guide-2025S, 对应文档第0-2章的内容","title":"rCore 学习笔记0"}]