[{"content":"本文内容 总结到chapter4的内容，练习和问答作业，重点是地址空间隔离机制的实现。\n地址空间隔离 实现机制 [todo]\n地址映射关系 一图流，秒了（画图画累了，写不动了，后面再补充文字描述吧[todo]）\ntrap陷入过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 __alltraps: csrrw sp, sscratch, sp # now sp-\u0026gt;*TrapContext in user space, sscratch-\u0026gt;user stack # save other general purpose registers sd x1, 1*8(sp) # skip sp(x2), we will save it later sd x3, 3*8(sp) # skip tp(x4), application does not use it # save x5~x31 .set n, 5 .rept 27 SAVE_GP %n .set n, n+1 .endr # we can use t0/t1/t2 freely, because they have been saved in TrapContext csrr t0, sstatus csrr t1, sepc sd t0, 32*8(sp) sd t1, 33*8(sp) # read user stack from sscratch and save it in TrapContext csrr t2, sscratch sd t2, 2*8(sp) # load kernel_satp into t0 ld t0, 34*8(sp) # load trap_handler into t1 ld t1, 36*8(sp) # move to kernel_sp ld sp, 35*8(sp) # switch to kernel space csrw satp, t0 sfence.vma # jump to trap_handler jr t1 流程如下：\n1-22行：保存trap context（即当前所有寄存器的值）到用户栈上\n当trap发生时，此时还处于用户空间，然后sp和sscratch分别指向用户栈顶和用户栈上的trap context。执行csrrw之后，sp指向了分配的trap context，然后就可以开始执行保存trap context的操作：就是执行一系列的sd操作，将寄存器的值保存到sp指向的trap context中。需要注意真正需要保存的x2（即sp）的值在sscratch中，需要特殊处理一下。\n23-31 行：从用户空间切换到内核空间，跳转到trap handler执行\n执行到 23 行时我们仍处于用户空间，具体来说，我们需要设置 3 个寄存器的值，这 3 个寄存器的值都从trap context中获取。\n设置sp寄存器，指向内核栈 设置ra寄存器，指向trap handler 设置stap寄存器，指向内核空间（页表）的根地址，此时就切换到内核空间了 需要注意，由于这些寄存器的值是从用户栈上的获取，必须必须在第 30 行设置stap之前完成读取。\n32-33行：跳到trap_handler，这里使用jump register 而不是像第二章时直接call trap_handler，是因为后者是根据相对虚拟地址来跳转，而前者是根据绝对虚拟地址。开启MMU后，由于我们的trampline和实际物理地址不是直接映射，所以相对虚拟地址就不对了\n完成设置之后，就可以跳转到trap handler，在内核地址空间里\t处理trap了\n以上流程的正确执行需要如下Preconditions：\n已经在用户栈上分配了trap context的空间，且其中保存了3个重要的值：内核栈地址、trap handler地址、内核空间根页表物理地址 sp指向用户栈顶，sscratch指向用户栈上的trap context 然后执行之后存在如下Postconditions：\n处于内核地址空间 sp指向内核栈顶 用户进程的trap context已经保存到了用户栈上，且sscratch指向用户栈顶 trap返回过程 [todo]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 __restore: # a0: *TrapContext in user space(Constant); a1: user space token # switch to user space csrw satp, a1 sfence.vma csrw sscratch, a0 mv sp, a0 # now sp points to TrapContext in user space, start restoring based on it # restore sstatus/sepc ld t0, 32*8(sp) ld t1, 33*8(sp) csrw sstatus, t0 csrw sepc, t1 # restore general purpose registers except x0/sp/tp ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr # back to user stack ld sp, 2*8(sp) sret Preconditions: a0 指向用户栈上的trap context，a1指向用户空间根页表物理地址 流程如下： 1-5行：切换回用户空间 6行：将a0保存到sscratch 7行-23行：根据a0恢复trap context 24行：sret回到用户态（U mode） Postconditions： sscratch指向用户栈上的trap context 处于用户地址空间 已经根据trap context重置了寄存器状态 相关问题 以下问题是我个人学习过程中的遇到的几个困惑点，以及思考后得出来的答案，类似于官方的问答作业吧。如果这些问题你都能答得上来的话，说明本章的内容你掌握的很好了。（当然答案都是我的个人理解，如果有误，欢迎指正）\n假设存在N个app，此时有几个页表？有几个虚拟页同时映射到trampoline这个物理页？\n答：朴素的答案是N+1，N+2。考虑系统调用时，会通过PageTable::from_token，构造一个临时页表用于访问用户空间，但是该临时页表其实也是复用的用户页表的根页表，所以不会影响答案。\n为什么call trap_handler需要换成jr t1？为啥call只能是对pc的相对虚拟地址调整，而不能是直接对pc赋值为绝对虚拟地址？\n答：原因和地址长度及指令长度相关。\n如果我使用call trap_handler，是否有可能能够正常执行？如果去掉.text.trampoline之后的align(4K)之后，有没有可能呢？如果在内核态出错（比如call trap_handler导致出错）会发生什么情况\n为啥需要在用户空间专门分配一个页面来保存trap context，而不是继续保存在内核栈上？\n答：因为只有一个备用寄存器sscratch，无法同时保存satp和kernel_stack_top的值。于是我们统一将satp和kernel_stack_top的值保存用户页面上中，然后scratch保存该页面的地址即可通过sscratch同时获取这两个值了。\n为啥需要 set_kernel_trap_entry和 set_user_trap_entry？\n在用户态执行时（陷入内核之前），sscratch的值是啥？\n答：始终等于TRAP_CONTEXT_BASE。\ntrap_context中有哪些变量是用于读的，哪些是用于写的？用于读的的变量的值在初始化之后会被修改吗？\n答：kernel_stap, kernel_sp, trap_handler是用于读的，其余是用于写的。其中kernel_satp和kernel_sp在初始化之后保持不变，而trap_handler在进入trap_handler时会被设置成trap_from_kernel，而在进入trap_return时会被设置回TRAMPOLINE。\nchapter4练习 实现内容 重写 sys_get_time 和 sys_trace 实现mmap 和 munmap 实现概要 以下是一些重要注意事项（待完善，[todo]）\nPageTable::from_token只是用于trap后处于内核空间时，通过该token临时构造一个用于查询用户内存空间的页表，该页表不会被赋值给satp，不进行实际的地址转换作用，不负责管理用户帧的分配回收，frames置为空。\n而在sys_mmap中涉及到分配frame之后，就不再能够使用PageTable::from_token临时构造页表了，而是直接使用用户空间的原始内核页表，而且光使用页表也是不够的，需要直接调用 memory_set的insert_framed_area 方法添加一个map_area。\n尝试构造非法虚拟地址，看调用sys_get_time或sys_trace是否符合预期，返回 -1\n为啥测试用例调用 4 次get_time，但只是assert(3 \u0026lt;= count(sys_get_time))?\n页表标志位用法：最低一级页表的pte，除了V标志位以外，RWXU标志位也有效（因为pte中存的是物理帧地址），而其它级别页表由于pte中存的是下一级的页表的物理地址，所以只有V标志位有用。而且有一个细节，最低一级页表的pte的标志位是在PageTable::map中完成的，而其它级别页表的pte的标志位是在PageTable::find_pte_create中设置的。\n最低一级页表的RWXU标志位是根据逻辑段MapArea的map permission来设置，因此用户可访问权限的逻辑段的初始化，一定要赋予该U权限。\n与该标志位设置相关的bugfix：\n问答作业 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？\n答：页表项总共64位，可以这样记：高10位为保留字段，低10位为标志位，中间44位为物理页号.\n其中各个标志位的作用为：\nV: 页表项是否合法 R/W/X：对该页表项所指向的物理页面是否有读/写/执行权限。（参看实现概要中我的思考，这些字段仅针对第三级页表项） U：是否允许 CPU 在处于 U 特权级时访问该页表项所指向的物理页面 A：自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过 D：自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过 缺页\n缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。\n请问哪些异常可能是缺页导致的？\n答：[todo]\n发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。\n缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\n这样做有哪些好处？ 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？ 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\n此时页面失效如何表现在页表项(PTE)上？ 双页表与单页表\n为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n在单页表情况下，如何更换页表？ 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问） 单页表有何优势？（回答合理即可） 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ ","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","summary":"系列: rCore-Camp-Guide-2025S","title":"rCore 学习笔记2"},{"content":"本文内容 总结chapter3的内容，相关练习和简答作业。\n实现解读 参考[rCore-Camp-Guide-2025S 文档，我对ch3分支的新增代码实现的个人解读。\n多道程序加载 链接地址和加载地址 在说明多道程序加载的实现之前，我们现说明一下两个概念：\n链接地址：即程序编译链接后二进制文件中的地址。\n加载地址：即程序在加载到内存中实际执行时的地址。\nok，然后我们再来说多道程序加载，第二章实现的是一个批处理系统，该系统一次只会加载一个用户程序，每次需要执行下个程序时，再加载指定用户程序。而多道程序加载就是说，内核在初始化的时候就将多个用户程序同时加载到了其指定执行地址，这时就要求每个用户程序的加载地址必须不同了，否则不就可能发生覆盖了嘛。\n这就是我们需要解决的问题：即保证每个用户程序有不同的加载地址。朴素的做法，就是给每个用户程序指定一个起始地址偏移即可。\n在第四章之前，kernel还没有实现地址空间隔离机制，此时用户程序的加载地址等于其链接地址。所以，如果用户程序的加载地址不同，就需要用户程序的链接地址也不同。\n接下来，就看我们是怎么控制链接地址和装载地址，来解决多道程序加载引入的地址冲突问题的。\n链接过程 用户程序的链接地址，自然是要去看user/目录下各个用户程序二进制文件是怎么构建出来的，该过程由build.py脚本来控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # user/build.py for app in apps: app = app[: app.find(\u0026#34;.\u0026#34;)] os.system( \u0026#34;cargo rustc --bin %s %s -- -Clink-args=-Ttext=%x\u0026#34; % (app, mode_arg, base_address + step * app_id) ) print( \u0026#34;[build.py] application %s start with address %s\u0026#34; % (app, hex(base_address + step * app_id)) ) if chapter == \u0026#39;3\u0026#39;: app_id = app_id + 1 这里-Clink-arg=-Text=base_address + step * app_id指了定构建之后的代码段的起始地址。在链接脚本也能实现，只是这次通过给rustc传递编译参数的方式来实现，比较方便。\n这里关键就是13-14行，可以看出如果chapter2的话，每个用户的起始地址都是base_address。如果是chapter3，那么每个用户程序链接后会有一个step的地址偏移。只要我们保证step足够大，就能保证每个用户程序链接到不同的地址处，这就解决了链接地址的冲突。\n加载过程 再来看加载的过程，该过程通过load_apps控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /// Load nth user app at /// [APP_BASE_ADDRESS + n * APP_SIZE_LIMIT, APP_BASE_ADDRESS + (n+1) * APP_SIZE_LIMIT). pub fn load_apps() { extern \u0026#34;C\u0026#34; { fn _num_app(); } let num_app_ptr = _num_app as usize as *const usize; let num_app = get_num_app(); let app_start = unsafe { core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1) }; // load apps for i in 0..num_app { let base_i = get_base_i(i); // clear region (base_i..base_i + APP_SIZE_LIMIT) .for_each(|addr| unsafe { (addr as *mut u8).write_volatile(0) }); // load app from data section to memory let src = unsafe { core::slice::from_raw_parts(app_start[i] as *const u8, app_start[i + 1] - app_start[i]) }; let dst = unsafe { core::slice::from_raw_parts_mut(base_i as *mut u8, src.len()) }; dst.copy_from_slice(src); } } 其实现很自然，就是按照链接地址的约定，每个用户程序加载到不同的地址偏移处。（具体操作是，是从数据段复制到代码段的指定地址处，可参考note0 [todo]）\n总结 为每个用户程序引入了一个地址偏移，这样就保证了同时加载用户程序时，不会出现地址冲突。\n分时多任务 基于时间片轮转。\n[todo]\nchapter3练习 实现内容 实现系统调用sys_trace，该系统调用的作用是获取当前任务的系统调用的历史信息，该系统调用接口如下：\n1 fn sys_trace(trace_request: usize, id: usize, data: usize) -\u0026gt; isize 具体来说，其作用根据参数trace_request的值细分为3种：\n0：读指定地址 1：写指定地址 2：查询指定系统调用被调用过的次数 实现概要 这是我的个人实现的思考过程，不涉及具体代码实现，只提供一些思路拓展或注意事项。\ntrace_request=0、1 就是读写指定地址变量，实现很自然（chapter4 引入地址空间隔离之后，读写也会变的麻烦）\ntrace_request=2 的请求需要注意，这一次调用也计入统计。所以我们更新系统调用次数的处理逻辑需要在 sys_call 开头处，在分发系统调用逻辑之前实现。\n那么统计次数用什么数据结构来记录维护呢？很自然的想到用 HashMap，但是 HashMap 是 std 中的实现，所以我们没法用。那只能用线性容器了，毕竟系统调用的个数不多，线性查找可以接受。为了简单起见，直接用定长数组即可（其实也可以用 Vec，因为初始化时已经 init_heap 了，所以可以使用堆容器 Vec）。\n我将这个定长数组命名为 syscall_counter，显然数组元素为一个系统调用号到计数的 k-v 键值对即可，而数组长度如何确定呢，我的实现是新增了一个包含所有系统调用号的常量数组 SYSCALL_ARRAY，基于该数组我们可以确定 syscall_counter 的长度，以及数组元素需要包含的所有 key 信息。\n所以我们的syscall_counter的类型定义为：[(usize, usize); SYSCALL_ARRAY.len()]。\n确定好了数据结构，具体这个 syscall_counter 保存放在哪里呢？需要注意，系统调用次数查询是针对当前任务的，也就是说每个任务系统调用的次数统计是独立的，所以我们将 syscall_counter 放在 task manager 中。自然，初始化的逻辑就放在初始化 task manager 的 lazy_static 宏中。\n然后就是统计信息更新过程，就如上文所说，需要放在 sys_call 开头，线性查找到指定 key 将 value 自增 1 即可。最后，我们查找 syscall_counter 中给定 key 的 value，即可实现 sys_trace 的查询功能。\n当读第4章代码时，我发现我们的syscall_counter其实也可以使用BTreeMap，这玩意定义是在core中而不是在std中。\n问答作业 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 三个 bad 测例 (ch2b_bad_*.rs) ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。\n答：运行命令：\n1 2 3 cd os git checkout ch3 make run LOG=INFO BASE=1 出错行为如下：\nch2b_bad_address：触发StorePageFault异常，在trap_handler中报错并退出执行 ch2b_bad_instructions：触发IllegalInstruction异常，在trap_handler中报错并退出执行 ch2b_bad_register：触发IllegalInstruction异常，在trap_handler中报错并退出执行 深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:\nL40：刚进入 __restore 时，sp 代表了什么值。请指出 __restore 的两种使用情景。\n答：sp此时保存着内核栈顶地址。[todo]\nL43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。\n1 2 3 4 5 6 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 L50-L56：为何跳过了 x2 和 x4？\n1 2 3 4 5 6 7 ld x1, 1*8(sp) ld x3, 3*8(sp) .set n, 5 .rept 27 LOAD_GP %n .set n, n+1 .endr 答：x2即sp，目前指向栈顶，需要设置完其它寄存器后再设置，即通过L60的csrrw sp, sscratch, sp来设置x2，x4是tp(Thread pointer)线程寄存器，暂时不需要设置。\nL60：该指令之后，sp 和 sscratch 中的值分别有什么意义？\n1 csrrw sp, sscratch, sp 答：执行后，sp指向用户栈，sscratch指向内核栈。\n__restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？\n答：L61行的srete发生状态切换。因为该指令会根据sstatus寄存器中的SPP标志位决定切换到什么状态，而SPP标志位在之前从用户态陷入内核态时，就被设置成了标志用户态。\nL13：该指令之后，sp 和 sscratch 中的值分别有什么意义？\n1 csrrw sp, sscratch, sp 答：执行后，sp指向内核栈，sscratch指向用户栈。\n从 U 态进入 S 态是哪一条指令发生的？\n答：ecall指令。\n","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","summary":"系列: rCore-Camp-Guide-2025S","title":"rCore 学习笔记1"},{"content":"本文内容 总结到chapter0到chapter2中的重要内容。\n内核初始化过程 相关文件 os/src/entry.asm\nos/src/link_app.S\nos/src/main.rs\n具体过程 1 2 3 4 5 6 7 pub fn rust_main() -\u0026gt; ! { clear_bss(); logging::init(); trap::init(); batch::init(); batch::run_next_app(); } [todo]\n构建运行过程 相关文件 os/Makefile user/Makefile user/build.py 构建（build） 1 2 3 4 5 6 7 8 9 10 11 12 build: env $(KERNEL_BIN) env: (rustup target list | grep \u0026#34;riscv64gc-unknown-none-elf (installed)\u0026#34;) || rustup target add $(TARGET) cargo install cargo-binutils rustup component add rust-src rustup component add llvm-tools-preview $(KERNEL_BIN): kernel @$(OBJCOPY) $(KERNEL_ELF) --strip-all -O binary $@ kernel: @make -C ../user build TEST=$(TEST) CHAPTER=$(CHAPTER) BASE=$(BASE) @echo Platform: $(BOARD) @cargo build $(MODE_ARG) 即构建可执行的内核二进制文件KERNEL_BIN，这玩意就是我们需要构建的目标产物，就是我们的kernel的实体，或者说叫内核镜像吧。\n构建过程如下：\nenv：测试构建环境\nkernel：进入到../user目录执行make build命令，构建用户程序文件。再执行cargo build命令build二进制文件。这里是关键。构建出来的用户程序二进制文件到底是怎么和内核二进制文件关联起来的呢？就是通过如下这行代码，执行了link_app.S中的汇编代码：\n1 2 // os/src/main.rs global_asm!(include_str!(\u0026#34;link_app.S\u0026#34;)); 而link_app.S中的代码做的事情就是，将用户的二进制程序文件映射到内核二进制的数据段中。同时还生成了_num_app、app_0_start、app_0_end等符号，这样rust代码就可以利用这些符号找到各个用户程序的二进制了，需要运行某个用户程序时，就通过这些符号找到数据段中的指定用户程序的代码，将其复制到代码段中就可以执行了，该过程的具体代码查看load_app函数（该函数实现方式在chapter2和chapter3中有所不同，具体请看note2中的加载过程章节[todo] ）。\n$(KERNEL_BIN)：--strip-all去除多余信息，生成最终的镜像。\n运行（run） 1 2 3 4 5 @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios $(BOOTLOADER) \\ -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA) 即运行qemu跑我们的内核，需要指定若干参数：\nfile=：指定的需要加载运行的内核镜像路径，即我们上面说的KERNEL_BIN。 addr=：指定内核加载地址。 链接过程 相关文件 os/src/linker.ld 具体过程 编译链接之后，程序中的每个变量符号被替换成了具体的地址值（不清楚的参考csapp相关章节）。\n一般来说，我们不需要关心具体的地址值是多少，交给链接器来决定就好。上层应用不关心变量的具体地址，只要别把不同变量映射到同个地址就行。\n但是们在链接内核二进制时，就需要关心了，比如设定各个段的加载地址，加载顺序，地址对齐等，主要包括text、rodata、data、bss这四个段。同时也添加一些符号，比如stext，etext来标记代码段的起始地址和终止地址。\n所以总结，链接脚本的作用就是控制链接后的二进制文件的地址空间布局。\n","permalink":"https://csmyx.github.io/zh/posts/rcore-camp-guide-2025s/rcore-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/","summary":"系列: rCore-Camp-Guide-2025S","title":"rCore 学习笔记0"}]